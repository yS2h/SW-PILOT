# ⏰시간 복잡도

<br/>

## 목차

1. [시간 복잡도란](#시간-복잡도란)

2. [Big O 표기법이란](#big---o-)

3. [문제 코드의 시간 복잡도 분석](#시간-복잡도를-분석해-보자-)

<br/>

## 시간 복잡도란

**시간 복잡도(Time Complexity)** 는 알고리즘이 수행되는 데 걸리는 시간을 입력 크기(n)에 따라 수학적으로 분석한 것이다. 시간 복잡도를 통해 <u>알고리즘의 성능을 설명</u>할 수 있다.

컴퓨터 성능에 따라 실행 시간이 달라질 수 있기에, 실제 실행 시간보다는 명령문의 실행 빈도수를 계산하여 실행 시간을 구한다.

복잡도가 높은 알고리즘은 입력 크기가 커질수록 실행 시간이 급격하게 증가하므로, 성능에 큰 영향을 줄 수 있다. 따라서 알고리즘을 작성할 때는 시간 복잡도를 고려하여 가능한 한 효율적인 코드를 작성하는 것이
중요하다.

<br/>

## Big - O ❔❓

![Image](https://github.com/user-attachments/assets/cb6f8eaf-c392-40ef-98fb-67326595da4e)
**Big O 표기법**은 알고리즘 성능을 수학적으로 표현할 때 사용하는 방식으로, <u>최악의 경우</u>(상한선 기준으로) 수행 시간을 나타낸다.

### 표기법 특징

1. 상수항 무시

2. 영향력 없는 항 무시

### 성능 비교

#### O(1) > O(log n) > O(n) >  O(n log n) > O(n^2) > O(2^n)

- **O(1)**: 입력 크기에 상관없이 일정한 시간 (ex. 배열에서 인덱스로 접근)

- **O(n)**: 입력 크기에 비례하여 수행 시간 증가 (ex. 선형 탐색)

- **O(n^2)**: 이중 루프 사용 (ex. 버블 정렬)

- **O(log n)**: 로그 단계마다 절반씩 나누는 방식 (ex. 이진 탐색)

- **O(n log n)**: 효율적인 정렬 알고리즘 (ex. 병합 정렬)

- **O(2^n)**: 입력 크기 n에 대해 가능한 모든 조합을 탐색 (ex. 재귀적 부분 집합 생성)

 <br/>

## 시간 복잡도를 분석해 보자 ☑️

### 문제 1

```
// 성능에 가장 큰 영향을 끼치는 부분
for (String s : args) { ... } 
for (int i : list) { ... } 
for (int i : list) { ... } 
```

➡️ O(n)

**병목 현상** : ❌

---

### 문제 2

```
// 성능에 가장 큰 영향을 끼치는 부분
for (int i = 0; i < input.length(); i++) 
while (!s.isEmpty()) 
```

➡️ O(n)

**병목 현상** : ⭕

`stack.remove(stack.size() - 1);`

**최적화 방안** : ArrayList의 remove(int index)는 해당 인덱스 뒤의 요소들을 앞으로 모두 이동시켜야 하므로 O(n) 의 시간이 걸린다. 배열 기반 스택으로 구현하면 O(1)로 동작
가능하다.
